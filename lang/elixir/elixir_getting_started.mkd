# Elixir: Getting Started

http://elixir-lang.org/getting-started/introduction.html


## Introduction

### repl

`iex` for repl

`$ elixir simple.exs` to run your code

Inside the repl you can `c("module_name.ex")` to load the module

## Basic Types

### Types

```
iex> 1          # integer
iex> 0x1F       # integer
iex> 1.0        # float
iex> true       # boolean
iex> :atom      # atom / symbol
iex> "elixir"   # string
iex> [1, 2, 3]  # list
iex> {1, 2, 3}  # tuple
```


Binary, Octal, Hex

```iex
iex> 0b1010 # binary 10

iex> 0o777 # Octal 511

iex> 0x1F # Hex 31
```

Floats in Elixir are 64 bit double precision `1.0` or `1.0e-10`

`round(3.58)` for nearest int

`trunc(3.58)` for the int part (3)

Booleans

```iex
iex> is_boolean(true)
true

iex> is_boolean(1)
false
```

Can also check for `is_integer/1`, `is_float/1` or `is_number/1`

### Identifying functions

Functions are idenfitied by name and *arity*. e.g. `round/1` take 1 arg and `round/2` takes 2

### Atoms

**Atoms** are constants whose value is the name `:hello`

Note: true/false are also atoms `true == :true`

### Strings

```iex

iex(1)> "hellö #{:world}"
"hellö world"

iex(2)> IO.puts "hello\nworld"
hello
world
:ok

iex(3)> is_binary("hellö")
true

iex(4)> byte_size("hellö")
6

iex(5)> String.length("hellö")
5

iex(6)> String.upcase("hellö")
"HELLÖ"
```

### Anonymous Functions

Called using `.` to distinguish between regular and anon functions

```iex
iex> add = fn a, b -> a + b end
#Function<12.71889879/2 in :erl_eval.expr/5>

iex> add.(1, 2)
3

iex> is_function(add)
true

iex> is_function(add, 2) # check if add is a function that expects exactly 2 arguments
true

iex> is_function(add, 1) # check if add is a function that expects exactly 1 argument
false
```

Anon functions are **closures**

```iex
iex(9)> a
2

iex(10)> double = fn a -> a = a * 2 end
#Function<6.118419387/1 in :erl_eval.expr/5>

iex(11)> double.(a)
4

iex(12)> a
2
```

### (Linked) Lists

Basic lists and operators
```
iex(13)> [1, 2, true, 3]
[1, 2, true, 3]

iex(14)> [1, 2, 3] ++ [4,5,6]
[1, 2, 3, 4, 5, 6]

iex(15)> [1,true,2,false,3,true] -- [true,false]
[1, 2, 3, true]
```

Head/Tail
```
iex> list = [1, 2, 3]

iex> hd(list)
1

iex> tl(list)
[2, 3]
```

A list consisting of printable ASCII numbers get printed as a char list
```
iex> [11, 12, 13]
'\v\f\r'

iex> [104, 101, 108, 108, 111]
'hello'
```

`i` to inspect
```
iex(16)> i 'hello'
Term
  'hello'
Data type
  List
Description
  This is a list of integers that is printed as a sequence of characters
  delimited by single quotes because all the integers in it represent valid
  ASCII characters. Conventionally, such lists of integers are referred to as
  "charlists" (more precisely, a charlist is a list of Unicode codepoints,
  and ASCII is a subset of Unicode).
Raw representation
  [104, 101, 108, 108, 111]
Reference modules
  List
Implemented protocols
  IEx.Info, List.Chars, Enumerable, String.Chars, Collectable, Inspect
```

`'` != `"`
```
iex> 'hello' == "hello"
false
```

### Tuples

Tuples are stored contiguously in memory => fast accessing by index or getting size

```
iex> tuple = {:ok, "hello"}
{:ok, "hello"}

iex> elem(tuple, 1)
"hello"

iex> tuple_size(tuple)
2
```

`put_elem` to insert into a tuple
```
iex> tuple = {:ok, "hello"}
{:ok, "hello"}

iex> put_elem(tuple, 1, "world")
{:ok, "world"}

iex> tuple
{:ok, "hello"}
```

:boom: the original tuple was not modified since data is **immutable**

`tuple = put_elem(...)` would assign a new tuple

### List vs Tuple

| List | Tuple |
| ---- | ----- |
| stored as linked list | stored contiguously |
| fast prepending | expensive to modify |
| slower sizing | fast to get size |
| slower read | fast read by index |

Prepending to a list
```
iex> list = [1 | [2 | [3 | []]]]
[1, 2, 3]

iex> [0 | list]
[0, 1, 2, 3]
```

Example of tuple usage in `File.read/1`
```
iex> File.read("path/to/existing/file")
{:ok, "... contents ..."}

iex> File.read("path/to/unknown/file")
{:error, :enoent}
```

Elixir will generally guide you to the right thing.
- `size` for constant time op vs `length` for liner (both start with l)

e.g. `byte_size`, `tuple_size` vs `length`, `String.length`

## Basic operators

`++` and `--` to manipulate lists

`<>` string concat

`or`, `and`, `not` expext **booleans**

`||`, `&&`, `!` accept any arg type

`==`, `!=`, `===`, `!==`, `<=`, `>=`, `<`, and `>` as comparison operators

We can compare and sort any data types e.g. `1 < :atom`

Sort order is: `number < atom < reference < function < port < pid < tuple < map
< list < bitstring`

## Pattern matching

### The match operator

`=` is the **match operator**

```iex

iex> 1 = x
1

iex> 2 = x
** (MatchError) no match of right hand side value: 1

```

Can be used as a comparison or to assign if on left side
```
iex> 1 = unknown
** (CompileError) iex:1: undefined function unknown/0
```

### Pattern matching

Can match on other types

```
iex> {a, b, c} = {:hello, "world", 42}
{:hello, "world", 42}

iex> a
:hello
```

We can also match on specific values

```
iex> {:ok, result} = {:ok, 13}
{:ok, 13}

iex> result
13

iex> {:ok, result} = {:error, :oops}
** (MatchError) no match of right hand side value: {:error, :oops}
```

Also can match on lists
```
iex> [head | tail] = [1, 2, 3]
[1, 2, 3]

iex> head
1

iex> tail
[2, 3]
```

### The pin operator

Use `^` when you want to pattern match rather than reassign a var

```
iex> x = 2
2

iex> x = 1
1

iex> ^x = 2
** (MatchError) no match of right hand side value: 2

iex> {y, ^x} = {2, 1}
{2, 1}

iex> y
2

iex> {y, ^x} = {2, 2}
** (MatchError) no match of right hand side value: {2, 2}
```

We can also use `_` to throwaway a remainder match

```
iex> [h | _] = [1, 2, 3]
[1, 2, 3]

iex> h
1
```

`_` is inaccessible and gives unbound variable error if we try to read it

We cannot use a function on the left side
```
iex(1)>  length([1, [2], 3]) = 3
** (CompileError) iex:1: illegal pattern

iex(1)> 3= length([1, [2], 3])  3
```

## case, cond and if

### case

```elixir
case {1, 2, 3} do
  {4, 5, 6} ->
    IO.puts "This clause won't match"
  {1, x, 3} ->
    IO.puts "This clause will match and bind x to 2 in this clause"
    IO.puts x # 2
  _ ->
    IO.puts "This clause would match any value"
end
```

If you don't want x reassigned, make sure to use `^x`

Can also add a **guard** clause 
```
case {1, 2, 3} do
	{1, x, 3} when x > 0 ->
```

### Expressions in guard clauses


Elixir imports and allows the following expressions in guards by default:

* comparison operators (`==`, `!=`, `===`, `!==`, `>`, `>=`, `<`, `<=`)
* boolean operators (`and`, `or`, `not`)
* arithmetic operations (`+`, `-`, `*`, `/`)
* arithmetic unary operators (`+`, `-`)
* the binary concatenation operator `<>`
* the `in` operator as long as the right side is a range or a list
* all the following type check functions:
	* `is_atom/1`
	* `is_binary/1`
	* `is_bitstring/1`
	* `is_boolean/1`
	* `is_float/1`
	* `is_function/1`
	* `is_function/2`
	* `is_integer/1`
	* `is_list/1`
	* `is_map/1`
	* `is_nil/1`
	* `is_number/1`
	* `is_pid/1`
	* `is_port/1`
	* `is_reference/1`
	* `is_tuple/1`
* plus these functions:
	* `abs(number)`
	* `binary_part(binary, start, length)`
	* `bit_size(bitstring)`
	* `byte_size(bitstring)`
	* `div(integer, integer)`
	* `elem(tuple, n)`
	* `hd(list)`
	* `length(list)`
	* `map_size(map)`
	* `node()`
	* `node(pid | ref | port)`
	* `rem(integer, integer)`
	* `round(number)`
	* `self()`
	* `tl(list)`
	* `trunc(number)`
	* `tuple_size(tuple)`

:boom: bool operators `and, or, not` are allowed by `&&, ||, !` are **not**

Can also have user defined guards. e.g. *Bitwise* module defines additional ones

Anonymouse functions can ahve multiple clauses/guard as long as arity is the same

```
iex> f = fn
...>   x, y when x > 0 -> x + y
...>   x, y -> x * y
...> end
#Function<12.71889879/2 in :erl_eval.expr/5>

iex> f.(1, 3)
4

iex> f.(-1, 3)
-3
```

### cond

Equivalent to `else if`. More generic `case`

```elixir
iex> cond do
...>   2 + 2 == 5 ->
...>     "This is never true"
...>   2 * 2 == 3 ->
...>     "Nor this"
...>   true ->
...>     "This is always true (equivalent to else)"
...> end
```

If no clause is true then a `CondClauseError` is thrown. Note the `true` clause 
in the above example

### if and unless

`if true do`

`unless true do`

### do/end blocks

`if true do ... end` is equivalent to `if true, do: ( ... )`

## Binaries, strings and char lists

### UTF-8 and Unicode

UTF8 support `str = "hełło"` 

With UTF8, `byte_size(str)` != `String.length(str)`

To get a char's **code point** `?a` (= 97) or `?ł` (= 322)

`String.codepoints(str)` to split into individual characters

*Note* Doesn't look like we can use `arr[0]` to access array elements. This 
works though `Enum.at(String.codepoints(str), 0)` or 
`Enum.fetch(String.codepoints(str), 0)` which returns a tuple with `:ok` or 
`:error` if it's out of bounds 

### Binaries (and bitstrings)

`<<0, 1, 2, 3>>` to define a binary

`<>` to concatenate

:boom: trick to see inner binary repr. of a string is to concatenate null byte 
`"hello" <> <<0>>`

Binaries can be used to store larger than 255

```
iex> <<256 :: size(16)>> # use 16 bits (2 bytes) to store the number
<<1, 0>>

iex> <<256 :: utf8>> # the number is a code point
"Ā"
```

`is_bitstring` to check

`is_binary` requires that bits are divisible by 8

```
iex>  is_binary(<<1 :: size(16)>>)
true
iex>  is_binary(<<1 :: size(15)>>)
false
```

We can pattern match on binary/bitstring
```
iex> <<0, 1, x>> = <<0, 1, 2>>
<<0, 1, 2>>

iex> x
2

iex> <<0, 1, x>> = <<0, 1, 2, 3>>
** (MatchError) no match of right hand side value: <<0, 1, 2, 3>>
```

### Char lists

char list == list of code points

```
iex> 'hełło'
[104, 101, 322, 322, 111]

iex> is_list 'hełło'
true

iex> 'hello'
'hello'

iex> List.first('hello')
104
```

Mostly used to interface with older libraries in Erlang that do not accept 
binaries as arguments.

```
iex> to_charlist "hełło"
[104, 101, 322, 322, 111]

iex> to_string 'hełło'
"hełło"

iex> to_string :hello
"hello"

iex> to_string 1
"1"
```

## Keywords and maps

### Keyword lists

**keyword list :=** a list of tuples where the first item of each tuple is an 
atom

`list = [{:a, 1}, {:b, 2}]`

`list ++ [c: 3]` to concatenate


3 characteristics of a keyword list
- Keys must be **atoms**.
- Keys are **ordered**, as specified by the developer.
- Keys can be given **more than once**.

3 examples that are equivalent
```
iex> if false, do: :this, else: :that
:that

iex> if(false, [do: :this, else: :that])
:that

iex> if(false, [{:do, :this}, {:else, :that}])
:that
```

[Keyword module](https://hexdocs.pm/elixir/Keyword.html) for additional 
functions for working with keyword lists

:boom: Keyword lists are lists, therefore provide linear performance. 

Use **maps** instead for better performance with guaranteed one-key associates

### Maps

```elixir
iex> map = %{:a => 1, 2 => :b}
%{2 => :b, :a => 1}

iex> map[2]
:b
```

Maps
- allow any value as a key
- not ordered

When a map is used in a pattern, it will match on a subset of the given value

```elixir
iex> %{} = %{:a => 1, 2 => :b}
%{2 => :b, :a => 1}

iex> %{:a => a} = %{:a => 1, 2 => :b}
%{2 => :b, :a => 1}

iex> a
1

iex> %{:c => c} = %{:a => 1, 2 => :b}
** (MatchError) no match of right hand side value: %{2 => :b, :a => 1}
```

Variables can be used when accessing, matching, adding map keys
```elixir
iex> n = 1
1

iex> map = %{n => :one}
%{1 => :one}

iex> map[n]
:one

iex> %{^n => :one} = %{1 => :one, 2 => :two, 3 => :three}
%{1 => :one, 2 => :two, 3 => :three}iex>
```

[Map module for more functions](https://hexdocs.pm/elixir/Map.html)

`Map.get`, `Map.put`, `Map.to_list`

To update a key's value
`%{map | 2 => "two"}`

can also `map.a` to access an atom key

### Nested data structures

```elixir
users = [
  john: %{name: "John", age: 27, languages: ["Erlang", "Ruby", "Elixir"]},
  mary: %{name: "Mary", age: 29, languages: ["Elixir", "F#", "Clojure"]}
]

users[:john].age

users = put_in users[:john].age, 31

users = update_in users[:mary].languages, fn languages ->
  List.delete(languages, "Clojure")
end
```

## Modules and Functions

## Recursion

## Enumerables and streams

## Processes

## IO and the file system

## alias, require and import

## Module attributes

## Structs

## Protocols

## Comprehensions

## Sigils

## try, catch and rescue

## Typespecs and behaviours

## Erlang libraries

## Where to go next

Learn docker next 
https://blog.codeship.com/running-rails-development-environment-docker/
