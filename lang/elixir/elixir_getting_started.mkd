# Elixir: Getting Started

http://elixir-lang.org/getting-started/introduction.html


## Introduction

### repl

`iex` for repl

`$ elixir simple.exs` to run your code

Inside the repl you can `c("module_name.ex")` to load the module

## Basic Types

### Types

```
iex> 1          # integer
iex> 0x1F       # integer
iex> 1.0        # float
iex> true       # boolean
iex> :atom      # atom / symbol
iex> "elixir"   # string
iex> [1, 2, 3]  # list
iex> {1, 2, 3}  # tuple
```


Binary, Octal, Hex

```iex
iex> 0b1010 # binary 10

iex> 0o777 # Octal 511

iex> 0x1F # Hex 31
```

Floats in Elixir are 64 bit double precision `1.0` or `1.0e-10`

`round(3.58)` for nearest int

`trunc(3.58)` for the int part (3)

Booleans

```iex
iex> is_boolean(true)
true

iex> is_boolean(1)
false
```

Can also check for `is_integer/1`, `is_float/1` or `is_number/1`

### Identifying functions

Functions are idenfitied by name and *arity*. e.g. `round/1` take 1 arg and `round/2` takes 2

### Atoms

**Atoms** are constants whose value is the name `:hello`

Note: true/false are also atoms `true == :true`

### Strings

```iex

iex(1)> "hellö #{:world}"
"hellö world"

iex(2)> IO.puts "hello\nworld"
hello
world
:ok

iex(3)> is_binary("hellö")
true

iex(4)> byte_size("hellö")
6

iex(5)> String.length("hellö")
5

iex(6)> String.upcase("hellö")
"HELLÖ"
```

### Anonymous Functions

Called using `.` to distinguish between regular and anon functions

```iex
iex> add = fn a, b -> a + b end
#Function<12.71889879/2 in :erl_eval.expr/5>

iex> add.(1, 2)
3

iex> is_function(add)
true

iex> is_function(add, 2) # check if add is a function that expects exactly 2 arguments
true

iex> is_function(add, 1) # check if add is a function that expects exactly 1 argument
false
```

Anon functions are **closures**

```iex
iex(9)> a
2

iex(10)> double = fn a -> a = a * 2 end
#Function<6.118419387/1 in :erl_eval.expr/5>

iex(11)> double.(a)
4

iex(12)> a
2
```

### (Linked) Lists

Basic lists and operators
```
iex(13)> [1, 2, true, 3]
[1, 2, true, 3]

iex(14)> [1, 2, 3] ++ [4,5,6]
[1, 2, 3, 4, 5, 6]

iex(15)> [1,true,2,false,3,true] -- [true,false]
[1, 2, 3, true]
```

Head/Tail
```
iex> list = [1, 2, 3]

iex> hd(list)
1

iex> tl(list)
[2, 3]
```

A list consisting of printable ASCII numbers get printed as a char list
```
iex> [11, 12, 13]
'\v\f\r'

iex> [104, 101, 108, 108, 111]
'hello'
```

`i` to inspect
```
iex(16)> i 'hello'
Term
  'hello'
Data type
  List
Description
  This is a list of integers that is printed as a sequence of characters
  delimited by single quotes because all the integers in it represent valid
  ASCII characters. Conventionally, such lists of integers are referred to as
  "charlists" (more precisely, a charlist is a list of Unicode codepoints,
  and ASCII is a subset of Unicode).
Raw representation
  [104, 101, 108, 108, 111]
Reference modules
  List
Implemented protocols
  IEx.Info, List.Chars, Enumerable, String.Chars, Collectable, Inspect
```

`'` != `"`
```
iex> 'hello' == "hello"
false
```

### Tuples

Tuples are stored contiguously in memory => fast accessing by index or getting size

```
iex> tuple = {:ok, "hello"}
{:ok, "hello"}

iex> elem(tuple, 1)
"hello"

iex> tuple_size(tuple)
2
```

`put_elem` to insert into a tuple
```
iex> tuple = {:ok, "hello"}
{:ok, "hello"}

iex> put_elem(tuple, 1, "world")
{:ok, "world"}

iex> tuple
{:ok, "hello"}
```

:boom: the original tuple was not modified since data is **immutable**

`tuple = put_elem(...)` would assign a new tuple

### List vs Tuple

| List | Tuple |
| ---- | ----- |
| stored as linked list | stored contiguously |
| fast prepending | expensive to modify |
| slower sizing | fast to get size |
| slower read | fast read by index |

Prepending to a list
```
iex> list = [1 | [2 | [3 | []]]]
[1, 2, 3]

iex> [0 | list]
[0, 1, 2, 3]
```

Example of tuple usage in `File.read/1`
```
iex> File.read("path/to/existing/file")
{:ok, "... contents ..."}

iex> File.read("path/to/unknown/file")
{:error, :enoent}
```

Elixir will generally guide you to the right thing.
- `size` for constant time op vs `length` for liner (both start with l)

e.g. `byte_size`, `tuple_size` vs `length`, `String.length`

## Basic operators

`++` and `--` to manipulate lists

`<>` string concat

`or`, `and`, `not` expext **booleans**

`||`, `&&`, `!` accept any arg type

`==`, `!=`, `===`, `!==`, `<=`, `>=`, `<`, and `>` as comparison operators

We can compare and sort any data types e.g. `1 < :atom`

Sort order is: `number < atom < reference < function < port < pid < tuple < map
< list < bitstring`

## Pattern matching

### The match operator

`=` is the **match operator**

```iex

iex> 1 = x
1

iex> 2 = x
** (MatchError) no match of right hand side value: 1

```

Can be used as a comparison or to assign if on left side
```
iex> 1 = unknown
** (CompileError) iex:1: undefined function unknown/0
```

### Pattern matching

Can match on other types

```
iex> {a, b, c} = {:hello, "world", 42}
{:hello, "world", 42}

iex> a
:hello
```

We can also match on specific values

```
iex> {:ok, result} = {:ok, 13}
{:ok, 13}

iex> result
13

iex> {:ok, result} = {:error, :oops}
** (MatchError) no match of right hand side value: {:error, :oops}
```

Also can match on lists
```
iex> [head | tail] = [1, 2, 3]
[1, 2, 3]

iex> head
1

iex> tail
[2, 3]
```

### The pin operator

Use `^` when you want to pattern match rather than reassign a var

```
iex> x = 2
2

iex> x = 1
1

iex> ^x = 2
** (MatchError) no match of right hand side value: 2

iex> {y, ^x} = {2, 1}
{2, 1}

iex> y
2

iex> {y, ^x} = {2, 2}
** (MatchError) no match of right hand side value: {2, 2}
```

We can also use `_` to throwaway a remainder match

```
iex> [h | _] = [1, 2, 3]
[1, 2, 3]

iex> h
1
```

`_` is inaccessible and gives unbound variable error if we try to read it

We cannot use a function on the left side
```
iex(1)>  length([1, [2], 3]) = 3
** (CompileError) iex:1: illegal pattern

iex(1)> 3= length([1, [2], 3])  3
```

## case, cond and if

### case

```elixir
case {1, 2, 3} do
  {4, 5, 6} ->
    IO.puts "This clause won't match"
  {1, x, 3} ->
    IO.puts "This clause will match and bind x to 2 in this clause"
    IO.puts x # 2
  _ ->
    IO.puts "This clause would match any value"
end
```

If you don't want x reassigned, make sure to use `^x`

Can also add a **guard** clause 
```
case {1, 2, 3} do
	{1, x, 3} when x > 0 ->
```

### Expressions in guard clauses


Elixir imports and allows the following expressions in guards by default:

* comparison operators (`==`, `!=`, `===`, `!==`, `>`, `>=`, `<`, `<=`)
* boolean operators (`and`, `or`, `not`)
* arithmetic operations (`+`, `-`, `*`, `/`)
* arithmetic unary operators (`+`, `-`)
* the binary concatenation operator `<>`
* the `in` operator as long as the right side is a range or a list
* all the following type check functions:
	* `is_atom/1`
	* `is_binary/1`
	* `is_bitstring/1`
	* `is_boolean/1`
	* `is_float/1`
	* `is_function/1`
	* `is_function/2`
	* `is_integer/1`
	* `is_list/1`
	* `is_map/1`
	* `is_nil/1`
	* `is_number/1`
	* `is_pid/1`
	* `is_port/1`
	* `is_reference/1`
	* `is_tuple/1`
* plus these functions:
	* `abs(number)`
	* `binary_part(binary, start, length)`
	* `bit_size(bitstring)`
	* `byte_size(bitstring)`
	* `div(integer, integer)`
	* `elem(tuple, n)`
	* `hd(list)`
	* `length(list)`
	* `map_size(map)`
	* `node()`
	* `node(pid | ref | port)`
	* `rem(integer, integer)`
	* `round(number)`
	* `self()`
	* `tl(list)`
	* `trunc(number)`
	* `tuple_size(tuple)`

:boom: bool operators `and, or, not` are allowed by `&&, ||, !` are **not**

Can also have user defined guards. e.g. *Bitwise* module defines additional ones

Anonymouse functions can ahve multiple clauses/guard as long as arity is the same

```
iex> f = fn
...>   x, y when x > 0 -> x + y
...>   x, y -> x * y
...> end
#Function<12.71889879/2 in :erl_eval.expr/5>

iex> f.(1, 3)
4

iex> f.(-1, 3)
-3
```

### cond



### if and unless
### do/end blocks

## Binaries, strings and char lists

## Keywords and maps

## Modules and Functions

## Recursion

## Enumerables and streams

## Processes

## IO and the file system

## alias, require and import

## Module attributes

## Structs

## Protocols

## Comprehensions

## Sigils

## try, catch and rescue

## Typespecs and behaviours

## Erlang libraries

## Where to go next

