# Elixir

http://elixir-lang.org/getting-started/introduction.html

See also:
- [Erlang/Elixir Syntax: A Crash 
  Course](https://elixir-lang.org/crash-course.html)
- [Learing Resources](https://elixir-lang.org/learning.html)

## Getting Started

### [Introduction](https://elixir-lang.org/getting-started/introduction.html)

#### repl

`iex` for repl

`$ elixir simple.exs` to run your code

Inside the repl you can `c("module_name.ex")` to load the module

### [Basic Types](https://elixir-lang.org/getting-started/basic-types.html)

#### Types

```
1          # integer
0x1F       # integer
1.0        # float
true       # boolean
:atom      # atom / symbol
"elixir"   # string
[1, 2, 3]  # list
{1, 2, 3}  # tuple
```


Binary, Octal, Hex

```iex
0b1010 # binary 10

0o777 # Octal 511

0x1F # Hex 31
```

Floats in Elixir are 64 bit double precision `1.0` or `1.0e-10`

`round(3.58)` for nearest int

`trunc(3.58)` for the int part (3)

Booleans

```iex
is_boolean(true)  # true

is_boolean(1)     # false
```

Can also check for `is_integer/1`, `is_float/1` or `is_number/1`

#### Identifying functions

Functions are idenfitied by name and *arity*. e.g. `round/1` take 1 arg and `round/2` takes 2

#### Atoms

**Atoms** are constants whose value is the name `:hello`

Note: true/false are also atoms `true == :true`

#### Strings

```iex

iex(1)> "hellö #{:world}"
"hellö world"

iex(2)> IO.puts "hello\nworld"
hello
world
:ok

iex(3)> is_binary("hellö")
true

iex(4)> byte_size("hellö")
6

iex(5)> String.length("hellö")
5

iex(6)> String.upcase("hellö")
"HELLÖ"
```

#### Anonymous Functions

Called using `.` to distinguish between regular and anon functions

```iex
iex> add = fn a, b -> a + b end
##Function<12.71889879/2 in :erl_eval.expr/5>

iex> add.(1, 2)
3

iex> is_function(add)
true

iex> is_function(add, 2) # check if add is a function that expects exactly 2 arguments
true

iex> is_function(add, 1) # check if add is a function that expects exactly 1 argument
false
```

Anon functions are **closures**

```iex
iex(9)> a
2

iex(10)> double = fn a -> a = a * 2 end
##Function<6.118419387/1 in :erl_eval.expr/5>

iex(11)> double.(a)
4

iex(12)> a
2
```

#### (Linked) Lists

Basic lists and operators
```
iex(13)> [1, 2, true, 3]
[1, 2, true, 3]

iex(14)> [1, 2, 3] ++ [4,5,6]
[1, 2, 3, 4, 5, 6]

iex(15)> [1,true,2,false,3,true] -- [true,false]
[1, 2, 3, true]
```

Head/Tail
```
iex> list = [1, 2, 3]

iex> hd(list)
1

iex> tl(list)
[2, 3]
```

A list consisting of printable ASCII numbers get printed as a char list
```
iex> [11, 12, 13]
'\v\f\r'

iex> [104, 101, 108, 108, 111]
'hello'
```

`i` to inspect
```
iex(16)> i 'hello'
Term
  'hello'
Data type
  List
Description
  This is a list of integers that is printed as a sequence of characters
  delimited by single quotes because all the integers in it represent valid
  ASCII characters. Conventionally, such lists of integers are referred to as
  "charlists" (more precisely, a charlist is a list of Unicode codepoints,
  and ASCII is a subset of Unicode).
Raw representation
  [104, 101, 108, 108, 111]
Reference modules
  List
Implemented protocols
  IEx.Info, List.Chars, Enumerable, String.Chars, Collectable, Inspect
```

`'` != `"`
```
iex> 'hello' == "hello"
false
```

#### Tuples

Tuples are stored contiguously in memory => fast accessing by index or getting size

```
iex> tuple = {:ok, "hello"}
{:ok, "hello"}

iex> elem(tuple, 1)
"hello"

iex> tuple_size(tuple)
2
```

`put_elem` to insert into a tuple
```
iex> tuple = {:ok, "hello"}
{:ok, "hello"}

iex> put_elem(tuple, 1, "world")
{:ok, "world"}

iex> tuple
{:ok, "hello"}
```

:boom: the original tuple was not modified since data is **immutable**

`tuple = put_elem(...)` would assign a new tuple

#### List vs Tuple

| List | Tuple |
| ---- | ----- |
| stored as linked list | stored contiguously |
| fast prepending | expensive to modify |
| slower sizing | fast to get size |
| slower read | fast read by index |

Prepending to a list
```
iex> list = [1 | [2 | [3 | []]]]
[1, 2, 3]

iex> [0 | list]
[0, 1, 2, 3]
```

Example of tuple usage in `File.read/1`
```
iex> File.read("path/to/existing/file")
{:ok, "... contents ..."}

iex> File.read("path/to/unknown/file")
{:error, :enoent}
```

Elixir will generally guide you to the right thing.
- `size` for constant time op vs `length` for liner (both start with l)

e.g. `byte_size`, `tuple_size` vs `length`, `String.length`

### [Basic operators](https://elixir-lang.org/getting-started/basic-operators.html)

#### Operators

`++` and `--` to manipulate lists

`<>` string concat

`or`, `and`, `not` expect a **boolean**

`||`, `&&`, `!` accept any arg type

`==`, `!=`, `===`, `!==`, `<=`, `>=`, `<`, and `>` as comparison operators

We can compare and sort any data types e.g. `1 < :atom`

Sort order is: `number < atom < reference < function < port < pid < tuple < map
< list < bitstring`

### [Pattern matching](https://elixir-lang.org/getting-started/pattern-matching.html)

#### The match operator

`=` is the **match operator**

```iex

iex> 1 = x
1

iex> 2 = x
** (MatchError) no match of right hand side value: 1

```

Can be used as a comparison or to assign if on left side
```
iex> 1 = unknown
** (CompileError) iex:1: undefined function unknown/0
```

#### Pattern matching

Can match on other types

```
iex> {a, b, c} = {:hello, "world", 42}
{:hello, "world", 42}

iex> a
:hello
```

We can also match on specific values

```
iex> {:ok, result} = {:ok, 13}
{:ok, 13}

iex> result
13

iex> {:ok, result} = {:error, :oops}
** (MatchError) no match of right hand side value: {:error, :oops}
```

Also can match on lists
```
iex> [head | tail] = [1, 2, 3]
[1, 2, 3]

iex> head
1

iex> tail
[2, 3]
```

#### The pin operator

Use `^` when you want to pattern match rather than reassign a var

```
iex> x = 2
2

iex> x = 1
1

iex> ^x = 2
** (MatchError) no match of right hand side value: 2

iex> {y, ^x} = {2, 1}
{2, 1}

iex> y
2

iex> {y, ^x} = {2, 2}
** (MatchError) no match of right hand side value: {2, 2}
```

We can also use `_` to throwaway a remainder match

```
iex> [h | _] = [1, 2, 3]
[1, 2, 3]

iex> h
1
```

`_` is inaccessible and gives unbound variable error if we try to read it

We cannot use a function on the left side
```
iex(1)>  length([1, [2], 3]) = 3
** (CompileError) iex:1: illegal pattern

iex(1)> 3= length([1, [2], 3])  3
```

### [case, cond and if](https://elixir-lang.org/getting-started/case-cond-and-if.html)

#### case

```elixir
case {1, 2, 3} do
  {4, 5, 6} ->
    IO.puts "This clause won't match"
  {1, x, 3} ->
    IO.puts "This clause will match and bind x to 2 in this clause"
    IO.puts x # 2
  _ ->
    IO.puts "This clause would match any value"
end
```

If you don't want **x reassigned**, make sure to use `^x`

Can also add a **guard** clause 
```
case {1, 2, 3} do
	{1, x, 3} when x > 0 ->
```

#### Expressions in guard clauses


Elixir imports and allows the following expressions in guards by default:

* comparison operators (`==`, `!=`, `===`, `!==`, `>`, `>=`, `<`, `<=`)
* boolean operators (`and`, `or`, `not`)
* arithmetic operations (`+`, `-`, `*`, `/`)
* arithmetic unary operators (`+`, `-`)
* the binary concatenation operator `<>`
* the `in` operator as long as the right side is a range or a list
* all the following type check functions:
	* `is_atom/1`
	* `is_binary/1`
	* `is_bitstring/1`
	* `is_boolean/1`
	* `is_float/1`
	* `is_function/1`
	* `is_function/2`
	* `is_integer/1`
	* `is_list/1`
	* `is_map/1`
	* `is_nil/1`
	* `is_number/1`
	* `is_pid/1`
	* `is_port/1`
	* `is_reference/1`
	* `is_tuple/1`
* plus these functions:
	* `abs(number)`
	* `binary_part(binary, start, length)`
	* `bit_size(bitstring)`
	* `byte_size(bitstring)`
	* `div(integer, integer)`
	* `elem(tuple, n)`
	* `hd(list)`
	* `length(list)`
	* `map_size(map)`
	* `node()`
	* `node(pid | ref | port)`
	* `rem(integer, integer)`
	* `round(number)`
	* `self()`
	* `tl(list)`
	* `trunc(number)`
	* `tuple_size(tuple)`

:boom: bool operators `and, or, not` are allowed by `&&, ||, !` are **not**

Can also have user defined guards. e.g. *Bitwise* module defines additional ones

Anonymouse functions can ahve multiple clauses/guard as long as arity is the same

```
iex> f = fn
...>   x, y when x > 0 -> x + y
...>   x, y -> x * y
...> end
##Function<12.71889879/2 in :erl_eval.expr/5>

iex> f.(1, 3)
4

iex> f.(-1, 3)
-3
```

#### cond

Equivalent to `else if`. More generic `case`

```elixir
cond do
  2 + 2 == 5 ->
    "This is never true"
  2 * 2 == 3 ->
    "Nor this"
  true ->
    "This is always true (equivalent to else)"
end
```

If no clause is true then a `CondClauseError` is thrown. Note the `true` clause 
in the above example

#### if and unless

`if true do`

`unless true do`

#### do/end blocks

`if true do ... end` is equivalent to `if true, do: ( ... )`

### [Binaries, strings and char lists](https://elixir-lang.org/getting-started/binaries-strings-and-char-lists.html)

#### UTF-8 and Unicode

UTF8 support `str = "hełło"` 

With UTF8, `byte_size(str)` != `String.length(str)`

To get a char's **code point** `?a` (= 97) or `?ł` (= 322)

`String.codepoints(str)` to split into individual characters

:caution: Doesn't look like we can use `arr[0]` to access array elements. This 
works though `Enum.at(String.codepoints(str), 0)` or 
`Enum.fetch(String.codepoints(str), 0)` which returns a tuple with `:ok` or 
`:error` if it's out of bounds 

#### Binaries (and bitstrings)

`<<0, 1, 2, 3>>` to define a binary

`<>` to concatenate

:boom: trick to see inner binary repr. of a string is to concatenate null byte 
`"hello" <> <<0>>`

Binaries can be used to store larger than 255

```
iex> <<256 :: size(16)>> # use 16 bits (2 bytes) to store the number
<<1, 0>>

iex> <<256 :: utf8>> # the number is a code point
"Ā"
```

`is_bitstring` to check

`is_binary` requires that bits are divisible by 8

```
iex>  is_binary(<<1 :: size(16)>>)
true
iex>  is_binary(<<1 :: size(15)>>)
false
```

We can pattern match on binary/bitstring
```
iex> <<0, 1, x>> = <<0, 1, 2>>
<<0, 1, 2>>

iex> x
2

iex> <<0, 1, x>> = <<0, 1, 2, 3>>
** (MatchError) no match of right hand side value: <<0, 1, 2, 3>>
```

#### Char lists

char list == list of code points

```
iex> 'hełło'
[104, 101, 322, 322, 111]

iex> is_list 'hełło'
true

iex> 'hello'
'hello'

iex> List.first('hello')
104
```

Mostly used to interface with older libraries in Erlang that do not accept 
binaries as arguments.

```
iex> to_charlist "hełło"
[104, 101, 322, 322, 111]

iex> to_string 'hełło'
"hełło"

iex> to_string :hello
"hello"

iex> to_string 1
"1"
```

### [Keywords and maps](https://elixir-lang.org/getting-started/keywords-and-maps.html)

#### Keyword lists

**keyword list :=** a list of tuples where the first item of each tuple is an 
atom

`list = [{:a, 1}, {:b, 2}]`

`list ++ [c: 3]` to concatenate


3 characteristics of a keyword list
- Keys must be **atoms**.
- Keys are **ordered**, as specified by the developer.
- Keys can be given **more than once**.

3 examples that are equivalent
```
if false, do: :this, else: :that            # :that

if(false, [do: :this, else: :that])         # :that

if(false, [{:do, :this}, {:else, :that}])   # :that
```

[Keyword module](https://hexdocs.pm/elixir/Keyword.html) for additional 
functions for working with keyword lists

:boom: Keyword lists are lists, therefore provide linear performance. 

Use **maps** instead for better performance with guaranteed one-key associates

#### Maps

```elixir
iex> map = %{:a => 1, 2 => :b}
%{2 => :b, :a => 1}

iex> map[2]
:b
```

Maps
- allow any value as a key
- not ordered

When a map is used in a pattern, it will match on a subset of the given value

```elixir
iex> %{} = %{:a => 1, 2 => :b}
%{2 => :b, :a => 1}

iex> %{:a => a} = %{:a => 1, 2 => :b}
%{2 => :b, :a => 1}

iex> a
1

iex> %{:c => c} = %{:a => 1, 2 => :b}
** (MatchError) no match of right hand side value: %{2 => :b, :a => 1}
```

Variables can be used when accessing, matching, adding map keys
```elixir
iex> n = 1
1

iex> map = %{n => :one}
%{1 => :one}

iex> map[n]
:one

iex> %{^n => :one} = %{1 => :one, 2 => :two, 3 => :three}
%{1 => :one, 2 => :two, 3 => :three}iex>
```

[Map module for more functions](https://hexdocs.pm/elixir/Map.html)

`Map.get`, `Map.put`, `Map.to_list`

To update a key's value
`%{map | 2 => "two"}`

can also `map.a` to access an atom key

#### Nested data structures

`put_in/2` and `update_in/2` are convenience functions for nested data

```elixir
users = [
  john: %{name: "John", age: 27, languages: ["Erlang", "Ruby", "Elixir"]},
  mary: %{name: "Mary", age: 29, languages: ["Elixir", "F#", "Clojure"]}
]

users[:john].age

users = put_in users[:john].age, 31

users = update_in users[:mary].languages, fn languages ->
  List.delete(languages, "Clojure")
end
```

### [Modules and Functions](https://elixir-lang.org/getting-started/modules-and-functions.html)

#### defModule

`defModule Math do`

#### Compilation

Given `math.ex` with following content:
```elixir
defmodule Math do
  def sum(a, b) do
    a + b
  end
end
```

Compile with `elixirc math.ex` to generate `Elixir.Math.beam`

Elixir project are organized in the following:
- `ebin` - contains the compiled bytecode
- `lib` - contains elixir code (usually .ex files)
- `test` - contains tests (usually .exs files)

#### Scripted mode

`.exs` == Elixir scripted files can be run with `elixir math.exs` without 
compiling

#### Named functions

`def` for public functions and `defp` for private functions

functions also support guards and multiple clauses e.g.
```elixir
defmodule Math do
  def zero?(0) do
    true
  end

  def zero?(x) when is_integer(x) do
    false
  end
end

IO.puts Math.zero?(0)         #=> true
IO.puts Math.zero?(1)         #=> false
IO.puts Math.zero?([1, 2, 3]) #=> ** (FunctionClauseError)
IO.puts Math.zero?(0.0)       #=> ** (FunctionClauseError)
```

#### Function capturing

Can capture function
- `&fun = &Math.zero?/1` to capture function in module
- `&is_function/1` to capture local or imported functions

#### Default arguments

```elixir
def join (a, b, sep \\ " ") do
  a <> sep <> b
end

IO.puts Concat.join("Hello", "world")      #=> Hello world
IO.puts Concat.join("Hello", "world", "_") #=> Hello_world
```

### [Recursion](https://elixir-lang.org/getting-started/recursion.html)

#### Loops through recursion

Elixir is **immutable** so loops work a little different. We have to rely on 
recursion instead of the standard `for(i = 0; i < size(arr); i++)` in 
imperative languages

```elixir
defmodule Recursion do

  def print_multiple_times(msg, n) when n <= 1 do
    IO.puts msg <> " final"
  end

  def print_multiple_times(msg, n) do
    IO.puts msg
    print_multiple_times(msg, n - 1)
  end

end

Recursion.print_multiple_times("Hello!", 3)
```

#### Reduce and map algorithms

**Reduce** with **tail call**

```elixir
def sum_list([head | tail], accumulator) do
  IO.puts "sum: [#{head}, #{Enum.join(tail, ", ")}] #{accumulator}"
  sum_list(tail, head + accumulator)
end

def sum_list([], accumulator) do
  IO.puts "accumulator: #{accumulator}"
  accumulator
end

Math.sum_list([1, 2, 3], 4) #=> 6
```

**Map**

```elixir
def double_each([head | tail]) do
  [head * 2 | double_each(tail)]
end

def double_each([]) do
  []
end

Math.double_each([1, 2, 3]) #=> [2, 4, 6]
```

#### Enum

`Enum` module provides conveniences for lists

```
Enum.reduce([1, 2, 3], 0, fn(x, acc) -> x + acc end)  # 6

Enum.reduce([1, 2, 3], 0, &+/2)                       # 6

Enum.map([1, 2, 3], fn(x) -> x * 2 end)               # [2, 4, 6]

Enum.map([1, 2, 3], &(&1 * 2))                        # [2, 4, 6]
```

### [Enumerables and streams](https://elixir-lang.org/getting-started/enumerables-and-streams.html)

#### Enumerables

Enum.map
```
Enum.map([1, 2, 3], fn x -> x * 2 end)                # [2, 4, 6]
Enum.map(%{1 => 2, 3 => 4}, fn {k, v} -> k * v end)   # [2, 12]
```

Enum ranges
```
Enum.map(1..3, fn x -> x * 2 end)                     # [2, 4, 6]
Enum.reduce(1..3, 0, &+/2)                            # 6
```

#### Eager vs Lazy

Enum functions are **eager**

`1..100_000 |> Enum.map(&(&1 * 3)) |> Enum.filter(odd?) |> Enum.sum`

Above does each operation before moving to the next one in the pipe

#### The pipe operator

Pipe operator allows for cleaner syntax. Above code is equivalent to
`Enum.sum(Enum.filter(Enum.map(1..100_000, &(&1 * 3)), odd?))`

#### Streams

`Stream` module unlike Enum provides **lazy** operators

`1..100_000 |> Stream.map(&(&1 * 3)) |> Stream.filter(odd?) |> Enum.sum`

Stream builds a series of computations that are only invoked when passed to 
Enum. Good for **large, possibly infinite** collections

Interesting Stream functions
- `Stream.cycle`
- `Stream.unfold`
- `File.stream!`

### [Processes](https://elixir-lang.org/getting-started/processes.html)

**Processes** are isolated from each other, run concurrent to one another and 
communicate via message passing
- extremely lightweight in terms of memory and CPU unlike threads 

#### spawn

Spawn a new process. Once spawned it is killed

```
iex> pid = spawn fn -> 1 + 2 end    # PID<0.44.0>
iex> Process.alive?(pid)            # false
```

#### send and receive

`send/2` message to a process and `receive/1`
- message is stored in process mailbox
- receive goes through mailbox and finds a match

```elixir
send self(), {:hello, "world"}            # {:hello, "world"}

receive do
  {:hello, msg} -> msg                    # "world"
  {:world, msg} -> "won't match"
end
```

Can set a timeout with `after`

`flush/0` flushes and prints all messages in mailbox

#### Links

`spawn_link/1` spawns linked processes

If we spawn a process that raises an error, it doesn't shut down the parent.

e.g. `spawn fn -> raise "oops" end`

Instead we can link them

`spawn_link fn -> raise "oops" end`

**Failing fast** we are actually fine with letting processes fail because we 
expect supervisors to properly restart our systems

#### Tasks

`Task` module builds on spawn to provide beter error reports and introspection

`Task.start fn -> raise "oops" end`

#### State

We can create a process that loops infinitely, maintains state, and 
sends/receives messages

e.g. Create a key-value store

```elixir
defmodule KV do

  def start_link do
    Task.start_link(fn -> loop(%{}) end)
  end

  defp loop(map) do
    receive do
      {:get, key, caller} ->
        send caller, Map.get(map, key)
        loop(map)
      {:put, key, value} ->
        loop(Map.put(map, key, value))
    end
  end
end
```

To test the module

```
{:ok, pid} = KV.start_link                # {:ok, #PID<0.62.0>}

send pid, {:get, :hello, self()}          # {:get, :hello, #PID<0.41.0>}

flush()                                   # nil
```

```
send pid, {:put, :hello, :world}          # {:put, :hello, :world}
send pid, {:get, :hello, self()}          # {:get, :hello, #PID<0.41.0>}
flush()                                   # :world
```

We can also name the `pid`

```
Process.register(pid, :kv)                # true
send :kv, {:get, :hello, self()}          # {:get, :hello, #PID<0.41.0>}
flush()                                   # :world
```

#### Agent

`Agent` is a simple abstractions around state

```
{:ok, pid} = Agent.start_link(fn -> %{} end)              # {:ok, #PID<0.72.0>}
iex> Agent.update(pid, fn map -> Map.put(map, :hello, :world) end)    # :ok
iex> Agent.get(pid, fn map -> Map.get(map, :hello) end)               # :world
```

### [IO and the file system](https://elixir-lang.org/getting-started/io-and-the-file-system.html)

#### The IO module

`IO.puts "hello world"`

`IO.gets "yes or no? "IO.gets "yes or no? "`

`IO.puts :stderr, "hello world"`

#### The File module

```
{:ok, file} = File.open "hello", [:write] # {:ok, #PID<0.47.0>}
IO.binwrite file, "world"                 # :ok
File.close file                           # :ok
File.read "hello"                         # {:ok, "world"}
```

Can handle different outcomes

```
case File.read(file) do
  {:ok, body}      -> # do something with the `body`
  {:error, reason} -> # handle the error caused by `reason`
end
```

#### The Path module

```
Path.join("foo", "bar")     # "foo/bar"
Path.expand("~/hello")      # "/Users/jose/hello"
```

### [alias, require and import](https://elixir-lang.org/getting-started/alias-require-and-import.html)

#### alias

`alias Foo.Bar, as: Bar` Alias the module so it can be called as Bar instead of 
Foo.Bar

#### require

`require Foo` Require the module in order to use its macros

#### import

`import Foo` Import functions from Foo so they can be called without the `Foo.` 
prefix

#### use

`use Foo` Invokes the custom code defined in Foo as an extension point

### [Module Attributes](https://elixir-lang.org/getting-started/module-attributes.html)

#### As annotations

Moduels can have annotations:
- `@vsn 2` used by VM to check if module has been updated
- `@moduledoc` - provides documentation for the current module.
- `@doc` - provides documentation for the function or macro
- `@behaviour` - used for specifying an OTP or user-defined behaviour.
- `@before_compile` - provides a hook that will be invoked before the module is 
  compiled. This makes it possible to inject functions inside the module 
  exactly before compilation.

#### As constants

`@my_data 14` is stored at compile time. Can be reassigned

### [Structs](https://elixir-lang.org/getting-started/structs.html)

#### Defining structs

**Structs** == extensions built on maps providing compile time checks and 
default values

`defstruct name: "John", age: 27`

Structs limit only the fields defined and requires that they all be assigned 
when created

#### Accessing and updating structs

```
john = %User{}                  # %User{age: 27, name: "John"}
john.name                       # "John"
meg = %{john | name: "Meg"}     # %User{age: 27, name: "Meg"}
```

#### Structs are bare maps underneath

```
is_map(john)      # true
john.__struct__   # User
```

Can use `Map` functions

```
kurt = Map.put(%User{}, :name, "Kurt")    # %User{age: 27, name: "Kurt"}
Map.merge(kurt, %User{name: "Takashi"})   # %User{age: 27, name: "Takashi"}
Map.keys(john)                            # [:__struct__, :age, :name]
```

#### Default values and required keys

`nil` is default value

Can also enforce some keys are specified

```elixir
defmodule Car do
  @enforce_keys [:make]
  defstruct [:model, :make]
end

%Car{}                        # ** (ArgumentError) the following keys ...

Car: [:make]                  #  expanding struct: Car.__struct__/1
```

### [Protocols](https://elixir-lang.org/getting-started/protocols.html)

#### Protocols

Allows **polymorphism** for all Elixir data types e.g. `Atom`, `List`, etc

`defprotocol` followed by `defimpl Class, for: myClass`

```elixir
defprotocol Size do

  @doc "Calculates the size (and not the length!) of a data structure"
  def size(data)
end

defimpl Size, for: BitString do
  def size(string), do: byte_size(string)
end

defimpl Size, for: Map do
  def size(map), do: map_size(map)
end

defimpl Size, for: Tuple do
  def size(tuple), do: tuple_size(tuple)
end
```

Can call `Size.size` on any implemented data types.

Throws `Protocol.UndefinedError` on unsupported data type

#### Implementing Any

##### Deriving

We can define a protocol on `Any` and `@derive` it

```elixir
defimpl Size, for: Any do
  def size(_), do: 0
end


defmodule OtherUser do
  @derive [Size]
  defstruct [:name, :age]
end
```

##### Fallback to Any

If we `@fallback_to_any true` then a data type that hasn't implemented the 
`defprotocol` won't throw the `Protocol.UndefinedError`

#### Built-in protocols

Some common protocols:
- `Enum.map`
- `Enum.reduce`
- `String.Chars` which is exposed via `to_string`
- `inspect` function based on `Inspect` protocol

### [Comprehensions](https://elixir-lang.org/getting-started/comprehensions.html)

#### Intro

**Comprehensions** == syntactic sugar for generators, filters, and collectables
- group these tasks into `for`

`for n <- [1, 2, 3, 4], do: n * n`

#### Generators and filters

**Generator** == `n <- [1,2,3,4]` from example above. Can be any enumerable

Also support pattern matching

```elixir
values = [good: 1, good: 2, bad: 3, good: 4]

for {:good, n} <- values, do: n * n             # [1, 4, 16]
```

Some advanced usage

Calculate file size in a dir
```elixir
dirs = ['/home/mikey', '/home/james']
for dir  <- dirs,
    file <- File.ls!(dir),
    path = Path.join(dir, file),
    File.regular?(path) do
  File.stat!(path).size
end
```

Cartesian product
```elixir
for i <- [:a, :b, :c], j <- [1, 2], do:  {i, j}
```

Pythagorean triplets
```elixir
defmodule Triple do
  def pythagorean(n) when n > 0 do
    for a <- 1..n-2,
        b <- a+1..n-1,
        c <- b+1..n,
        a + b + c <= n,
        a*a + b*b == c*c,
        do: {a, b, c}
  end
end

Triple.pythagorean(48)          # [{3, 4, 5}, {5, 12, 13}, {6, 8, 10},
                                # {8, 15, 17}, {9, 12, 15}, {12, 16, 20}]
```

#### The :into option

comprehensions generally return lists, but can return other data structs with 
`:into`

```
for {key, val} <- %{"a" => 1, "b" => 2}, into: %{}, do: {key, val * val}
```

### [Sigils](https://elixir-lang.org/getting-started/sigils.html)

**Sigils** == provided for working with textual representations

#### Regular expressions

Most common sigil is `~r` for regex. Allows us to use 8 different delimiters

e.g. `~r/hello/` == `~r(hello)` == `~r<hello>` etc

#### Strings, char lists, and word lists sigils

`~s(this is a string with "double" quotes, not 'single' ones)`

`~c(this is a char list containing 'single quotes')`

`~w(foo bar bat)`

#### Interpolation and escaping in sigils

lowercase sigils allow interpolation

```elixir
~s(String with escape codes \x26 #{"inter" <> "polation"})

~S(String without escape codes \x26 without #{interpolation})
```

Also support heredocs

```elixir
@doc ~S"""
    ### Examples
    iex> convert("\"foo\"")
    "'foo'"
"""
```

#### Custom sigils

`~r/foo/i` == `sigil_r(<<"foo">>, 'i')`

To see help `iex> h sigil_r`

Custom sigils can be defined

```elixir
defmodule MySigils do
  def sigil_i(string, []), do: String.to_integer(string)
  def sigil_i(string, [?n]), do: -String.to_integer(string)
end

~i(13) # 13

~i(42)n # -42
```

### [try, catch and rescue](https://elixir-lang.org/getting-started/try-catch-and-rescue.html)

#### Errors

`raise\1` to raise an error with "message"

`raise\2` to raise an error with error name (e.g. `Argumenterror`) and 
"message"

To create custom error module

```elixir
defmodule MyError, do: defexception message: "default message"

raise MyError                               # ** (MyError) default message
raise MyError, message: "custom message"    # ** (MyError) custom message
```

you can `try/rescue` but rarely used e.g. to rescue error on opening file it's 
better to parse the return tuple

```elixir
case File.read "hello" do
  {:ok, body}      -> IO.puts "Success: #{body}"
  {:error, reason} -> IO.puts "Error: #{reason}"
end
```

`throw` and `catch`

an `exit(1)` can also be caught

```elixir
try do
  exit "I am exiting"
catch
  :exit, _ -> "not really
end
```

`after` to do something an error is thrown

In a function, we can skip `try`

```elixir
def some_error do
  raise "oops"
after
  # so something
end
```

`else` can be used to continue after a try does *not* throw an error

Variables are scoped within `try/catch/rescue/after`

### [Typespecs and behaviours](https://elixir-lang.org/getting-started/typespecs-and-behaviours.html)

#### Types and specs

**typespecs** are notation for
- declaring typed function signatures (specifications);
- declaring custom data types.

##### Defining custom types

```elixir
@spec add(number, number) :: {number, String.t}
def add(x, y), do: {x + y, "You need a calculator to do that?!"}
```

:caution: not the `String.t` since it's a *remote* type. Same for `Map.t`, 
`Enum.t`

We can shortcut the `@type`

```elixir
@type num_str :: {number, String.t}

@spec add(number, number) :: num_str
```

`@type` is public. Use `@typep` to make private

##### Static code analysis

Using typespecs we can perform static analysis e.g.  
[Dialyzer](http://www.erlang.org/doc/man/dialyzer.html)

#### Behaviours

**Behaviours** provide a way to
- define a set of functions that have to be implemented by a module;
- ensure that a module implements all the functions in that set.

```elixir
defmodule Parser do
  @callback parse(String.t) :: any
  @callback extensions() :: [String.t]
end
```

Modules adopting `Parser` have to implement parse and extensions

```elixir
defmodule JSONParser do
  @behaviour Parser

  def parse(str), do: # ... parse JSON
  def extensions, do: ["json"]
end

defmodule YAMLParser do
  @behaviour Parser

  def parse(str), do: # ... parse YAML
  def extensions, do: ["yml"]
end
```

##### Defining behaviours
##### Adopting behaviours

### [Erlang libraries](https://elixir-lang.org/getting-started/erlang-libraries.html)

#### The binary module

[Handle UTF-8](http://erlang.org/doc/man/binary.html)

```elixir
iex> String.to_charlist "Ø"   # [216]
iex> :binary.bin_to_list "Ø"  # [195, 152]
```

#### Formatted text output

`:io.format/2` and `:io_lib.format/2` are equivalent to printf in C

```elixir
iex> :io.format("Pi is approximately given by:~10.3f~n", [:math.pi])
  Pi is approximately given by:     3.142
  :ok

iex> to_string :io_lib.format("Pi is approximately given by:~10.3f~n", [:math.pi])
  "Pi is approximately given by:     3.142\n"
```

#### The crypto module

[Crypto module](http://erlang.org/doc/man/crypto.html) contains hashing, 
digital signatures, encryption, etc

```elixir
iex> Base.encode16(:crypto.hash(:sha256, "Elixir"))
  "3315715A7A3AD57428298676C5AE465DADA38D951BDFAC9348A8A31E9C7401CB"
```

:caution: Crypto isn't part of stdlib. Must be added in `mix.exs`

```elixir
def application do
  [extra_applications: [:crypto]]
  end
```

#### The digraph module

[Digraph module](http://erlang.org/doc/man/digraph.html) for dealing with 
directed graphs built of vertices and edges

```elixir
iex> digraph = :digraph.new()
iex> coords = [{0.0, 0.0}, {1.0, 0.0}, {1.0, 1.0}]
iex> [v0, v1, v2] = (for c <- coords, do: :digraph.add_vertex(digraph, c))
iex> :digraph.add_edge(digraph, v0, v1)
iex> :digraph.add_edge(digraph, v1, v2)
iex> :digraph.get_short_path(digraph, v0, v2)
  [{0.0, 0.0}, {1.0, 0.0}, {1.0, 1.0}]
```

#### Erlang Term Storage

[ets](http://erlang.org/doc/man/ets.html) and 
[dets](http://erlang.org/doc/man/dets.html) handle storage of large data 
structures in memory or on disk respectively.

ETS
- table containing tuples
- protected tables ie only owner can write, but world readable
- functions in ets modify state of table as side effect

```elixir
iex> table = :ets.new(:ets_test, []) # Store as tuples with {name, population}
iex> :ets.insert(table, {"China", 1_374_000_000})
iex> :ets.insert(table, {"India", 1_284_000_000})
iex> :ets.insert(table, {"USA", 322_000_000})
iex> :ets.i(table)
  <1   > {<<"India">>,1284000000}
  <2   > {<<"USA">>,322000000}
  <3   > {<<"China">>,1374000000}
```

#### The math module

[Math module](http://erlang.org/doc/man/math.html) includes e.g. `:math.pi()`, 
`:math.sin()`, `:math.exp`, `:math.log`, etc

#### The queue module

[Queue module](http://erlang.org/doc/man/queue.html) implements FIFI queue

```elixir
iex> q = :queue.new
iex> q = :queue.in("A", q)
iex> q = :queue.in("B", q)
iex> {value, q} = :queue.out(q)
iex> value
  {:value, "A"}
iex> {value, q} = :queue.out(q)
iex> value
  {:value, "B"}
iex> {value, q} = :queue.out(q)
iex> value
  :empty
```

#### The rand module

[Rand module](http://erlang.org/doc/man/rand.html) for random values

```elixir
iex> :rand.uniform()   # 0.8175669086010815
iex> _ = :rand.seed(:exs1024, {123, 123534, 345345})
iex> :rand.uniform()   # 0.5820506340260994
iex> :rand.uniform(6)  # 6
```

#### The zip and zlib modules

[Zip module](http://erlang.org/doc/man/zip.html) for read/writing zip files

[Zlib module](http://erlang.org/doc/man/zlib.html) for read/write zlib like 
`gzip`



## Mix and OTP

### [Introduction to Mix](https://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html)

#### Intro

Build a complete Elixir application, with supervision tree, configuration, 
tests and more.

The application works as a distributed key-value store.
- organize key-value pairs into buckets
- distribute those buckets across multiple nodes.
- We will also build a simple client that allows us to connect to any of those 
  nodes and send requests

Use 3 tools
- OTP: build, fault-tolerant application
- Mix: tasks for creating, compiling, testing, dependencies, etc
- ExUnit: unit testing

#### Our first project

`mix help`

`mix new kv --module KV` creates a project
- `test/kv_test.exs` is corresponding test for ^

`mix.exs` configures the project. See `project` and `application`

#### Project compilation

`mix compile`
- `lib/kv.ex` is minimum needed to compile project

`iex -S mix` To run project in **iex**

#### Running tests

`mix test` to run tests
- `test/kv_test.exs`note the `.exs` since it doesn't need to be compiled
- `use ExUnit.Case` to inject testing API
- `test/test_helper.exs` sets up test framework

`mix test test/kv_test.exs:5` to run a specific line of a test file

#### Environments
- `:dev`
- `:test`
- `:prod`

To select a specific environment, edit `mix.exs` and set `Mix.Env`

Can also set `MIX_ENV=prod mix compile` as env var

#### Exploring

For a general mix overview https://hexdocs.pm/mix/Mix.html

### [Agent](https://elixir-lang.org/getting-started/mix-otp/agent.html)

#### The trouble with state

Elixir is **immutable** so we need to use either:
- Processes
- [ETS (Erlang Term Storage)](http://www.erlang.org/doc/man/ets.html)

To use Processes, we will use the following available abstractions:
- **Agent** Simple wrappers around state.
- **GenServer** “Generic servers” (processes) that encapsulate state, provide 
  sync and async calls, support code reloading, and more.
- **GenEvent** “Generic event” managers that allow publishing events to 
  multiple handlers.
- **Task** Asynchronous units of computation that allow spawning a process and 
  potentially retrieving its result at a later time.

#### Agents

Testing Agents

`iex -S mix`

```elixir
iex> {:ok, agent} = Agent.start_link fn -> [] end
{:ok, #PID<0.57.0>}

iex> Agent.update(agent, fn list -> ["eggs" | list] end)
:ok

iex> Agent.update(agent, fn list -> ["ham" | list] end)
:ok

iex> Agent.get(agent, fn list -> list end)
["ham", "eggs"]

iex> Agent.stop(agent)
:ok
```

#### Implement KV.Bucket

[test/kv/bucket_test.exs](https://github.com/arafatm/notes/commit/7c7a6923f40fc998c98a37e90554c871d0a5d12d)

we don't need to explicitly stop the agent since it's linked to the test 
process and will be shut down automagically

`async: true` makes tests run in parallel

[lib/kv/bucket_test.exs](https://github.com/arafatm/notes/commit/19cdd40f7a3568283a48a92a3c39f190cc6ebbc2)

#### Test setup with ExUnit callbacks

We can use `setup` *callback* in test https://github.com/arafatm/notes/commit/3722119

:boom: there was a typo in code above. Fixe in 
https://github.com/arafatm/notest/commit/e1acb90

Things to note:
- `setup` method is run on every test
- callback returns `{:ok, bucket: bucket}` and the 2nd element `bucket` is 
  merged into the test context
- passing `%{bucket: bucket}` to the test


#### Other agent actions

Implement `KV.Delete` using `Agent.get_and_update/2` 
https://github.com/arafatm/notes/commit/779300e

#### Client/Server in agents

### [GenServer](https://elixir-lang.org/getting-started/mix-otp/genserver.html)

#### Problem with Process

[Process](https://elixir-lang.org/getting-started/processes.html) names must be 
atoms. This is not ideal because **atoms are not garbage collected**.

#### Our first GenServer

[GenServer (hexdoc)](https://hexdocs.pm/elixir/GenServer.html) provides 
standard interface incl. tracing/reporting, and fits in supervision tree

Create [lib/kv/registry.ex](https://github.com/arafatm/notes/commit/dfa5ba6)

GenServer accepts 2 types of requests
- **calls** are sync and must get a response
- **casts** are async w/ no response

##### Client API

`start_link` starts GenServer
- `__MODULE` refers to this current module
- [3rd param can pass options](https://hexdocs.pm/elixir/GenServer.html#start_link/3) e.g. `:name`, `:timeout`, etc
-  returns `{:ok, pid}`

`lookup` and `create` for sending requests to server

##### Server API

`init/1` callback receives the 2nd argument from `start_link/3` and returns 
`{:ok, state}` where state is a map

Also implemented `handle_call/3` and `handle_cast/3`

#### Testing a GenServer

[test/kv/registry_test.exs](https://github.com/arafatm/notes/commit/5d86830)
- checks if registry "shopping" exists
- creates shopping registry
- adds item to shopping

We don't need to explicitly `:shutdown` the registry b'se tests will do so

To explicitly shutdown

```elixir
def stop(server) do
  GenServer.stop(server)
end
```

#### The need for monitoring

If a bucket stops/crashes it will remain in the registry. We can [verify this 
behavior](085368d)

The registry has to monitor every bucket it spawns

To test out a process monitor `iex -S mix`
```elixir
iex> {:ok, pid} = KV.Bucket.start_link  # {:ok, #PID<0.66.0>}
iex> Process.monitor(pid)               # Reference<0.0.0.551>
iex> Agent.stop(pid)                    # :ok
iex> flush()            # {:DOWN, #Reference<0.0.0.551>, :process, #PID<0.66.0>, :normal}
```

[KV.Registry changes](https://github.com/arafatm/notes/commit/ae84e99) to pass 
the test above

#### call, cast or info?

`handle_call/3` for synchronous requests. Should be the default choice

`handle_cast/2` for async reqs. Use sparingly b'se doesn't guarantee server has 
received a message

`handle_info/2` for all other messages. Use as a catch-all to avoid messages 
leading to critical failure

[See the GenServer Cheat 
Sheet](https://raw.githubusercontent.com/benjamintanweihao/elixir-cheatsheets/master/GenServer_CheatSheet.pdf)

#### Monitors or links?

Links are bi-directional := if a proc crashes the linked proc will crash as 
well

Monitor is uni-directional.

:boom: don't typically create new proc directly. Instead delegate to a 
supervisor

### [Supervisor and Application](https://elixir-lang.org/getting-started/mix-otp/supervisor-and-application.html)

### [ETS](https://elixir-lang.org/getting-started/mix-otp/ets.html)

### [Dependencies and umbrella apps](https://elixir-lang.org/getting-started/mix-otp/dependencies-and-umbrella-apps.html)

### [Task and gen-tcp](https://elixir-lang.org/getting-started/mix-otp/task-and-gen-tcp.html)

### [Docs, tests and with](https://elixir-lang.org/getting-started/mix-otp/docs-tests-and-with.html)

### [Distributed tasks and configuration](https://elixir-lang.org/getting-started/mix-otp/distributed-tasks-and-configuration.html)

## Meta-programming

### [Quote and unquote](https://elixir-lang.org/getting-started/meta/quote-and-unquote.html)

### [Macros](https://elixir-lang.org/getting-started/meta/macros.html)

### [Domain Specific Languages](https://elixir-lang.org/getting-started/meta/domain-specific-languages.html)


