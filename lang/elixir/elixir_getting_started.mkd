# Elixir: Getting Started

http://elixir-lang.org/getting-started/introduction.html


## Introduction

### repl

`iex` for repl

`$ elixir simple.exs` to run your code

Inside the repl you can `c("module_name.ex")` to load the module

## Basic Types

### Types

```
iex> 1          # integer
iex> 0x1F       # integer
iex> 1.0        # float
iex> true       # boolean
iex> :atom      # atom / symbol
iex> "elixir"   # string
iex> [1, 2, 3]  # list
iex> {1, 2, 3}  # tuple
```


Binary, Octal, Hex

```iex
iex> 0b1010 # binary 10

iex> 0o777 # Octal 511

iex> 0x1F # Hex 31
```

Floats in Elixir are 64 bit double precision `1.0` or `1.0e-10`

`round(3.58)` for nearest int

`trunc(3.58)` for the int part (3)

Booleans

```iex
iex> is_boolean(true)
true

iex> is_boolean(1)
false
```

Can also check for `is_integer/1`, `is_float/1` or `is_number/1`

### Identifying functions

Functions are idenfitied by name and *arity*. e.g. `round/1` take 1 arg and `round/2` takes 2

### Atoms

**Atoms** are constants whose value is the name `:hello`

Note: true/false are also atoms `true == :true`

### Strings

```iex

iex(1)> "hellö #{:world}"
"hellö world"

iex(2)> IO.puts "hello\nworld"
hello
world
:ok

iex(3)> is_binary("hellö")
true

iex(4)> byte_size("hellö")
6

iex(5)> String.length("hellö")
5

iex(6)> String.upcase("hellö")
"HELLÖ"
```

### Anonymous Functions

Called using `.` to distinguish between regular and anon functions

```iex
iex> add = fn a, b -> a + b end
#Function<12.71889879/2 in :erl_eval.expr/5>

iex> add.(1, 2)
3

iex> is_function(add)
true

iex> is_function(add, 2) # check if add is a function that expects exactly 2 arguments
true

iex> is_function(add, 1) # check if add is a function that expects exactly 1 argument
false
```

Anon functions are **closures**

```iex
iex(9)> a
2

iex(10)> double = fn a -> a = a * 2 end
#Function<6.118419387/1 in :erl_eval.expr/5>

iex(11)> double.(a)
4

iex(12)> a
2
```

### (Linked) Lists

Basic lists and operators
```
iex(13)> [1, 2, true, 3]
[1, 2, true, 3]

iex(14)> [1, 2, 3] ++ [4,5,6]
[1, 2, 3, 4, 5, 6]

iex(15)> [1,true,2,false,3,true] -- [true,false]
[1, 2, 3, true]
```

Head/Tail
```
iex> list = [1, 2, 3]

iex> hd(list)
1

iex> tl(list)
[2, 3]
```

A list consisting of printable ASCII numbers get printed as a char list
```
iex> [11, 12, 13]
'\v\f\r'

iex> [104, 101, 108, 108, 111]
'hello'
```

`i` to inspect
```
iex(16)> i 'hello'
Term
  'hello'
Data type
  List
Description
  This is a list of integers that is printed as a sequence of characters
  delimited by single quotes because all the integers in it represent valid
  ASCII characters. Conventionally, such lists of integers are referred to as
  "charlists" (more precisely, a charlist is a list of Unicode codepoints,
  and ASCII is a subset of Unicode).
Raw representation
  [104, 101, 108, 108, 111]
Reference modules
  List
Implemented protocols
  IEx.Info, List.Chars, Enumerable, String.Chars, Collectable, Inspect
```

`'` != `"`
```
iex> 'hello' == "hello"
false
```

### Tuples

Tuples are stored contiguously in memory => fast accessing by index or getting size

```
iex> tuple = {:ok, "hello"}
{:ok, "hello"}

iex> elem(tuple, 1)
"hello"

iex> tuple_size(tuple)
2
```

`put_elem` to insert into a tuple
```
iex> tuple = {:ok, "hello"}
{:ok, "hello"}

iex> put_elem(tuple, 1, "world")
{:ok, "world"}

iex> tuple
{:ok, "hello"}
```

:boom: the original tuple was not modified since data is **immutable**

`tuple = put_elem(...)` would assign a new tuple

### List vs Tuple

| List | Tuple |
| ---- | ----- |
| stored as linked list | stored contiguously |
| fast prepending | expensive to modify |
| slower sizing | fast to get size |
| slower read | fast read by index |

Prepending to a list
```
iex> list = [1 | [2 | [3 | []]]]
[1, 2, 3]

iex> [0 | list]
[0, 1, 2, 3]
```

Example of tuple usage in `File.read/1`
```
iex> File.read("path/to/existing/file")
{:ok, "... contents ..."}

iex> File.read("path/to/unknown/file")
{:error, :enoent}
```

Elixir will generally guide you to the right thing.
- `size` for constant time op vs `length` for liner (both start with l)

e.g. `byte_size`, `tuple_size` vs `length`, `String.length`

## Basic operators

`++` and `--` to manipulate lists

`<>` string concat

`or`, `and`, `not` expext **booleans**

`||`, `&&`, `!` accept any arg type

`==`, `!=`, `===`, `!==`, `<=`, `>=`, `<`, and `>` as comparison operators

We can compare and sort any data types e.g. `1 < :atom`

Sort order is: `number < atom < reference < function < port < pid < tuple < map
< list < bitstring`

## Pattern matching

### The match operator

`=` is the **match operator**

```iex

iex> 1 = x
1

iex> 2 = x
** (MatchError) no match of right hand side value: 1

```

Can be used as a comparison or to assign if on left side
```
iex> 1 = unknown
** (CompileError) iex:1: undefined function unknown/0
```

### Pattern matching

Can match on other types

```
iex> {a, b, c} = {:hello, "world", 42}
{:hello, "world", 42}

iex> a
:hello
```

We can also match on specific values

```
iex> {:ok, result} = {:ok, 13}
{:ok, 13}

iex> result
13

iex> {:ok, result} = {:error, :oops}
** (MatchError) no match of right hand side value: {:error, :oops}
```

Also can match on lists
```
iex> [head | tail] = [1, 2, 3]
[1, 2, 3]

iex> head
1

iex> tail
[2, 3]
```

### The pin operator

Use `^` when you want to pattern match rather than reassign a var

```
iex> x = 2
2

iex> x = 1
1

iex> ^x = 2
** (MatchError) no match of right hand side value: 2

iex> {y, ^x} = {2, 1}
{2, 1}

iex> y
2

iex> {y, ^x} = {2, 2}
** (MatchError) no match of right hand side value: {2, 2}
```

We can also use `_` to throwaway a remainder match

```
iex> [h | _] = [1, 2, 3]
[1, 2, 3]

iex> h
1
```

`_` is inaccessible and gives unbound variable error if we try to read it

We cannot use a function on the left side
```
iex(1)>  length([1, [2], 3]) = 3
** (CompileError) iex:1: illegal pattern

iex(1)> 3= length([1, [2], 3])  3
```

## case, cond and if

### case

```elixir
case {1, 2, 3} do
  {4, 5, 6} ->
    IO.puts "This clause won't match"
  {1, x, 3} ->
    IO.puts "This clause will match and bind x to 2 in this clause"
    IO.puts x # 2
  _ ->
    IO.puts "This clause would match any value"
end
```

If you don't want x reassigned, make sure to use `^x`

Can also add a **guard** clause 
```
case {1, 2, 3} do
	{1, x, 3} when x > 0 ->
```

### Expressions in guard clauses


Elixir imports and allows the following expressions in guards by default:

* comparison operators (`==`, `!=`, `===`, `!==`, `>`, `>=`, `<`, `<=`)
* boolean operators (`and`, `or`, `not`)
* arithmetic operations (`+`, `-`, `*`, `/`)
* arithmetic unary operators (`+`, `-`)
* the binary concatenation operator `<>`
* the `in` operator as long as the right side is a range or a list
* all the following type check functions:
	* `is_atom/1`
	* `is_binary/1`
	* `is_bitstring/1`
	* `is_boolean/1`
	* `is_float/1`
	* `is_function/1`
	* `is_function/2`
	* `is_integer/1`
	* `is_list/1`
	* `is_map/1`
	* `is_nil/1`
	* `is_number/1`
	* `is_pid/1`
	* `is_port/1`
	* `is_reference/1`
	* `is_tuple/1`
* plus these functions:
	* `abs(number)`
	* `binary_part(binary, start, length)`
	* `bit_size(bitstring)`
	* `byte_size(bitstring)`
	* `div(integer, integer)`
	* `elem(tuple, n)`
	* `hd(list)`
	* `length(list)`
	* `map_size(map)`
	* `node()`
	* `node(pid | ref | port)`
	* `rem(integer, integer)`
	* `round(number)`
	* `self()`
	* `tl(list)`
	* `trunc(number)`
	* `tuple_size(tuple)`

:boom: bool operators `and, or, not` are allowed by `&&, ||, !` are **not**

Can also have user defined guards. e.g. *Bitwise* module defines additional ones

Anonymouse functions can ahve multiple clauses/guard as long as arity is the same

```
iex> f = fn
...>   x, y when x > 0 -> x + y
...>   x, y -> x * y
...> end
#Function<12.71889879/2 in :erl_eval.expr/5>

iex> f.(1, 3)
4

iex> f.(-1, 3)
-3
```

### cond

Equivalent to `else if`. More generic `case`

```elixir
iex> cond do
...>   2 + 2 == 5 ->
...>     "This is never true"
...>   2 * 2 == 3 ->
...>     "Nor this"
...>   true ->
...>     "This is always true (equivalent to else)"
...> end
```

If no clause is true then a `CondClauseError` is thrown. Note the `true` clause 
in the above example

### if and unless

`if true do`

`unless true do`

### do/end blocks

`if true do ... end` is equivalent to `if true, do: ( ... )`

## Binaries, strings and char lists

### UTF-8 and Unicode

UTF8 support `str = "hełło"` 

With UTF8, `byte_size(str)` != `String.length(str)`

To get a char's **code point** `?a` (= 97) or `?ł` (= 322)

`String.codepoints(str)` to split into individual characters

*Note* Doesn't look like we can use `arr[0]` to access array elements. This 
works though `Enum.at(String.codepoints(str), 0)` or 
`Enum.fetch(String.codepoints(str), 0)` which returns a tuple with `:ok` or 
`:error` if it's out of bounds 

### Binaries (and bitstrings)

`<<0, 1, 2, 3>>` to define a binary

`<>` to concatenate

:boom: trick to see inner binary repr. of a string is to concatenate null byte 
`"hello" <> <<0>>`

Binaries can be used to store larger than 255

```
iex> <<256 :: size(16)>> # use 16 bits (2 bytes) to store the number
<<1, 0>>

iex> <<256 :: utf8>> # the number is a code point
"Ā"
```

`is_bitstring` to check

`is_binary` requires that bits are divisible by 8

```
iex>  is_binary(<<1 :: size(16)>>)
true
iex>  is_binary(<<1 :: size(15)>>)
false
```

We can pattern match on binary/bitstring
```
iex> <<0, 1, x>> = <<0, 1, 2>>
<<0, 1, 2>>

iex> x
2

iex> <<0, 1, x>> = <<0, 1, 2, 3>>
** (MatchError) no match of right hand side value: <<0, 1, 2, 3>>
```

### Char lists

char list == list of code points

```
iex> 'hełło'
[104, 101, 322, 322, 111]

iex> is_list 'hełło'
true

iex> 'hello'
'hello'

iex> List.first('hello')
104
```

Mostly used to interface with older libraries in Erlang that do not accept 
binaries as arguments.

```
iex> to_charlist "hełło"
[104, 101, 322, 322, 111]

iex> to_string 'hełło'
"hełło"

iex> to_string :hello
"hello"

iex> to_string 1
"1"
```

## Keywords and maps

### Keyword lists

**keyword list :=** a list of tuples where the first item of each tuple is an 
atom

`list = [{:a, 1}, {:b, 2}]`

`list ++ [c: 3]` to concatenate


3 characteristics of a keyword list
- Keys must be **atoms**.
- Keys are **ordered**, as specified by the developer.
- Keys can be given **more than once**.

3 examples that are equivalent
```
iex> if false, do: :this, else: :that
:that

iex> if(false, [do: :this, else: :that])
:that

iex> if(false, [{:do, :this}, {:else, :that}])
:that
```

[Keyword module](https://hexdocs.pm/elixir/Keyword.html) for additional 
functions for working with keyword lists

:boom: Keyword lists are lists, therefore provide linear performance. 

Use **maps** instead for better performance with guaranteed one-key associates

### Maps

```elixir
iex> map = %{:a => 1, 2 => :b}
%{2 => :b, :a => 1}

iex> map[2]
:b
```

Maps
- allow any value as a key
- not ordered

When a map is used in a pattern, it will match on a subset of the given value

```elixir
iex> %{} = %{:a => 1, 2 => :b}
%{2 => :b, :a => 1}

iex> %{:a => a} = %{:a => 1, 2 => :b}
%{2 => :b, :a => 1}

iex> a
1

iex> %{:c => c} = %{:a => 1, 2 => :b}
** (MatchError) no match of right hand side value: %{2 => :b, :a => 1}
```

Variables can be used when accessing, matching, adding map keys
```elixir
iex> n = 1
1

iex> map = %{n => :one}
%{1 => :one}

iex> map[n]
:one

iex> %{^n => :one} = %{1 => :one, 2 => :two, 3 => :three}
%{1 => :one, 2 => :two, 3 => :three}iex>
```

[Map module for more functions](https://hexdocs.pm/elixir/Map.html)

`Map.get`, `Map.put`, `Map.to_list`

To update a key's value
`%{map | 2 => "two"}`

can also `map.a` to access an atom key

### Nested data structures

```elixir
users = [
  john: %{name: "John", age: 27, languages: ["Erlang", "Ruby", "Elixir"]},
  mary: %{name: "Mary", age: 29, languages: ["Elixir", "F#", "Clojure"]}
]

users[:john].age

users = put_in users[:john].age, 31

users = update_in users[:mary].languages, fn languages ->
  List.delete(languages, "Clojure")
end
```

## Modules and Functions

### defModule

`defModule Math do`

### Compilation

Given `math.ex` with following content:
```elixir
defmodule Math do
  def sum(a, b) do
    a + b
  end
end
```

Compile with `elixirc math.ex` to generate `Elixir.Math.beam`

Elixir project are organized in the following:
- `ebin` - contains the compiled bytecode
- `lib` - contains elixir code (usually .ex files)
- `test` - contains tests (usually .exs files)

### Scripted mode

`.exs` == Elixir scripted files can be run with `elixir math.exs` without 
compiling

### Named functions

`def` for public functions and `defp` for private functions

functions also support guards and multiple clauses e.g.
```elixir
defmodule Math do
  def zero?(0) do
    true
  end

  def zero?(x) when is_integer(x) do
    false
  end
end

IO.puts Math.zero?(0)         #=> true
IO.puts Math.zero?(1)         #=> false
IO.puts Math.zero?([1, 2, 3]) #=> ** (FunctionClauseError)
IO.puts Math.zero?(0.0)       #=> ** (FunctionClauseError)
```

### Function capturing

Can capture function
- `&fun = &Math.zero?/1` to capture function in module
- `&is_function/1` to capture local or imported functions

### Default arguments

```elixir
def join (a, b, sep \\ " ") do
  a <> sep <> b
end

IO.puts Concat.join("Hello", "world")      #=> Hello world
IO.puts Concat.join("Hello", "world", "_") #=> Hello_world
```

## Recursion

### Loops through recursion

Elixir is **immutable** so loops work a little different. We have to rely on 
recursion instead of the standard `for(i = 0; i < size(arr); i++)` in 
imperative languages

```elixir
defmodule Recursion do

  def print_multiple_times(msg, n) when n <= 1 do
    IO.puts msg <> " final"
  end

  def print_multiple_times(msg, n) do
    IO.puts msg
    print_multiple_times(msg, n - 1)
  end

end

Recursion.print_multiple_times("Hello!", 3)
```

### Reduce and map algorithms

**Reduce** with **tail call**

```elixir
def sum_list([head | tail], accumulator) do
  IO.puts "sum: [#{head}, #{Enum.join(tail, ", ")}] #{accumulator}"
  sum_list(tail, head + accumulator)
end

def sum_list([], accumulator) do
  IO.puts "accumulator: #{accumulator}"
  accumulator
end

Math.sum_list([1, 2, 3], 4) #=> 6
```

**Map**

```elixir
def double_each([head | tail]) do
  [head * 2 | double_each(tail)]
end

def double_each([]) do
  []
end

Math.double_each([1, 2, 3]) #=> [2, 4, 6]
```

### Enum

`Enum` module provides conveniences for lists

```
Enum.reduce([1, 2, 3], 0, fn(x, acc) -> x + acc end)  # 6
                                                      # Same as
Enum.reduce([1, 2, 3], 0, &+/2)                       # 6

Enum.map([1, 2, 3], fn(x) -> x * 2 end)               # [2, 4, 6]
                                                      # Same as
Enum.map([1, 2, 3], &(&1 * 2))                        # [2, 4, 6]
```

## Enumerables and streams

### Enumerables

Enum.map
```
Enum.map([1, 2, 3], fn x -> x * 2 end)                # [2, 4, 6]
Enum.map(%{1 => 2, 3 => 4}, fn {k, v} -> k * v end)   # [2, 12]
```

Enum ranges
```
Enum.map(1..3, fn x -> x * 2 end)                     # [2, 4, 6]
Enum.reduce(1..3, 0, &+/2)                            # 6
```

### Eager vs Lazy

Enum functions are eager

`1..100_000 |> Enum.map(&(&1 * 3)) |> Enum.filter(odd?) |> Enum.sum`

Above does each operation before moving to the next one in the pipe

### The pipe operator

Pipe operator allows for cleaner syntax. Above code is equivalent to
`Enum.sum(Enum.filter(Enum.map(1..100_000, &(&1 * 3)), odd?))`

### Streams

`Stream` module unlike Enum provides lazy operators

`1..100_000 |> Stream.map(&(&1 * 3)) |> Stream.filter(odd?) |> Enum.sum`

Strem builds a series of computations that are only invoked when passed to 
Enum. Good for **large, possibly infinite** collections

Interesting Stream functions
- `Stream.cycle`
- `Stream.unfold`
- `File.stream!`

## Processes

**Processes** are isolated from each other, run concurrent to one another and 
communicate via message passing
- extremely lightweight in terms of memory and CPU unlike threads 

### spawn

Spawn a new process. Once spawned it is killed

```
iex> pid = spawn fn -> 1 + 2 end    # PID<0.44.0>
iex> Process.alive?(pid)            # false
```

### send and receive

`send/2` message to a process and `receive/1`
- message is stored in process mailbox
- receive goes through mailbox and finds a match

```elixir
send self(), {:hello, "world"}            # {:hello, "world"}

receive do
  {:hello, msg} -> msg                    # "world"
  {:world, msg} -> "won't match"
end
```

Can set a timeout with `after`

`flush/0` flushes and prints all messages in mailbox

### Links

`spawn_link/1` spawns linked processes

If we spawn a process that raises an error, it doesn't shut down the parent.

e.g. `spawn fn -> raise "oops" end`

Instead we can link them

`spawn_link fn -> raise "oops" end`

**Failing fast** we are actually fine with letting processes fail because we 
expect supervisors to properly restart our systems

### Tasks

`Task` module builds on spawn to provide beter error reports and introspection

`Task.start fn -> raise "oops" end`

### State

We can create a process that loops infinitely, maintains state, and 
sends/receives messages

e.g. Create a key-value store

```elixir
defmodule KV do

  def start_link do
    Task.start_link(fn -> loop(%{}) end)
  end

  defp loop(map) do
    receive do
      {:get, key, caller} ->
        send caller, Map.get(map, key)
        loop(map)
      {:put, key, value} ->
        loop(Map.put(map, key, value))
    end
  end
end
```

To test the module

```
{:ok, pid} = KV.start_link                # {:ok, #PID<0.62.0>}

send pid, {:get, :hello, self()}          # {:get, :hello, #PID<0.41.0>}

flush()                                   # nil
```

```
send pid, {:put, :hello, :world}          # {:put, :hello, :world}
send pid, {:get, :hello, self()}          # {:get, :hello, #PID<0.41.0>}
flush()                                   # :world
```

We can also name the `pid`

```
Process.register(pid, :kv)                # true
send :kv, {:get, :hello, self()}          # {:get, :hello, #PID<0.41.0>}
flush()                                   # :world
```

### Agent

`Agent` is a simple abstractions around state

```
{:ok, pid} = Agent.start_link(fn -> %{} end)              # {:ok, #PID<0.72.0>}
iex> Agent.update(pid, fn map -> Map.put(map, :hello, :world) end)    # :ok
iex> Agent.get(pid, fn map -> Map.get(map, :hello) end)               # :world
```

## IO and the file system

### The IO module

`IO.puts "hello world"`

`IO.gets "yes or no? "IO.gets "yes or no? "`

`IO.puts :stderr, "hello world"`

### The File module

```
{:ok, file} = File.open "hello", [:write] # {:ok, #PID<0.47.0>}
IO.binwrite file, "world"                 # :ok
File.close file                           # :ok
File.read "hello"                         # {:ok, "world"}
```

Can handle different outcomes

```
case File.read(file) do
  {:ok, body}      -> # do something with the `body`
  {:error, reason} -> # handle the error caused by `reason`
end
```

### The Path module

```
Path.join("foo", "bar")     # "foo/bar"
Path.expand("~/hello")      # "/Users/jose/hello"
```

## alias, require and import

### alias

`alias Foo.Bar, as: Bar` Alias the module so it can be called as Bar instead of 
Foo.Bar

### require

`require Foo` Require the module in order to use its macros

### import

`import Foo` Import functions from Foo so they can be called without the `Foo.` 
prefix

### use

`use Foo` Invokes the custom code defined in Foo as an extension point

## Module Attributes

### As annotations

Moduels can have annotations:
- `@vsn 2` used by VM to check if module has been updated
- `@moduledoc` - provides documentation for the current module.
- `@doc` - provides documentation for the function or macro
- `@behaviour` - used for specifying an OTP or user-defined behaviour.
- `@before_compile` - provides a hook that will be invoked before the module is 
  compiled. This makes it possible to inject functions inside the module 
  exactly before compilation.

### As constants

`@my_data 14` is stored at compile time. Can be reassigned

## Structs

### Defining structs

**Structs** == extensions built on maps providing compile time checks and 
default values

`defstruct name: "John", age: 27`

Structs limit only the fields defined and requires that they all be assigned 
when created

### Accessing and updating structs

```
john = %User{}                  # %User{age: 27, name: "John"}
john.name                       # "John"
meg = %{john | name: "Meg"}     # %User{age: 27, name: "Meg"}
```

### Structs are bare maps underneath

```
is_map(john)      # true
john.__struct__   # User
```

Can use `Map` functions

```
kurt = Map.put(%User{}, :name, "Kurt")    # %User{age: 27, name: "Kurt"}
Map.merge(kurt, %User{name: "Takashi"})   # %User{age: 27, name: "Takashi"}
Map.keys(john)                            # [:__struct__, :age, :name]
```

### Default values and required keys

`nil` is default value

Can also enforce some keys are specified

```elixir
defmodule Car do
  @enforce_keys [:make]
  defstruct [:model, :make]
end

%Car{}                        # ** (ArgumentError) the following keys ...

Car: [:make]                  #  expanding struct: Car.__struct__/1
```

## Protocols

### Protocols and structs

Allows **polymorphism** for all Elixir data types e.g. `Atom`, `List`, etc

`defprotocol` followed by `defimpl Class, for: myClass`

```elixir
defprotocol Size do

  @doc "Calculates the size (and not the length!) of a data structure"
  def size(data)
end

defimpl Size, for: BitString do
  def size(string), do: byte_size(string)
end

defimpl Size, for: Map do
  def size(map), do: map_size(map)
end

defimpl Size, for: Tuple do
  def size(tuple), do: tuple_size(tuple)
end
```

Can call `Size.size` on any implemented data types.

Throws `Protocol.UndefinedError` on unsupported data type

### Implementing Any
#### Deriving
#### Fallback to Any
### Built-in protocols
### Protocol consolidation

## Comprehensions

## try, catch and rescue

## Typespecs and behaviours

## Erlang libraries

## Where to go next

